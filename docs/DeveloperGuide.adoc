= Notably - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S2-CS2103T-W17-2/main/tree/master

By: `Team Notably`      Since: `Feb 2020`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

==== Design pattern and data flow

The App is built following the https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller[Model-View-Controller] design pattern.

In addition, the App's data flow is unidirectional. That is, all user interactions in `View` will trigger an appropriate handler in `Logic`, which in turn updates `Model` and `Storage`.
Any data/state changes in `Model` will then propagate back to `View` automatically through https://docs.oracle.com/javafx/2/binding/jfxpub-binding.htm[JavaFX's Property and Binding].

In short, the App's data flow can be summarized as: +
`View` -> `Logic` -> `Model` + `Storage` -> `View`

==== Architecture-level components

Overall, the App consists of four components:

* <<Design-View,*`View`*>>: View of the App.
* <<Design-Logic,*`Logic`*>>: Business logic of the App.
* <<Design-Model,*`Model`*>>: In-memory representation of the App's data/state.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

In addition, <<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

Each of the four components:

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `new -t Notably -b Lorem ipsum`.

.Component interactions for the `new -t Notably -b Lorem ipsum` command
image::ArchitectureSequenceDiagram.png[]

[[Design-View]]
=== View component

.Structure of the View Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/view/View.java[`View.java`]

The View consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `SuggestionsList`, `SideBarTree`, `HelpModal`, `BlockContent` etc. All these, including the `MainWindow`, inherit from the abstract `ViewPart` class.

The `View` component uses JavaFx framework. The layout of these View parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/view/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `View` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the View can be updated with the modified data.

[[Design-Logic]]
=== Logic component

.Architecture of Logic
image::LogicArchitectureDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]


`Logic` consists of 3 subcomponents:

* <<Design-NotablyParser,*`NotablyParser`*>>: Main parser of the App, deals with user command execution.
* <<Design-SuggestionEngine,*`SuggestionEngine`*>>: Deals with suggestions generation.
* <<Design-CorrectionEngine,*`CorrectionEngine`*>>: Deals with auto-correction.

// tag::parser[]
[[Design-NotablyParser]]
==== NotabyParser component

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

.  `Logic` uses the `NotablyParser` class to parse the user command.
.  This results in a `List<Command>` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a Note).
.  The updated model/data structure will automatically be reflected on to the `View`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete cs2103")` API call.

.Interactions Inside the Logic Component for the `delete -t cs2103` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

// end::parser[]
[[Design-SuggestionEngine]]
==== SuggestionEngine component

.Class Diagram of the Suggestion Engine Component (still WIP)
image::SuggestionClassDiagram.png[]

*API* :
link:{repoURL}blob/master/src/main/java/com/notably/logic/suggestion/SuggestionEngine.java[`SuggestionEngine.java`]

`SuggestionEngine` gives users the meaning of the command they input and a list of notes suggestions that they want to
open/ delete/ search/ edit.

1. `Logic` uses the `SuggestionEngineImpl` class, which implements `SuggestionEngine` interface, to parse the user command.
2. According to the command the user inputs, `SuggestionEngineImpl` will create a `XYZSuggestionCommandParser` object
which implements `SuggestionCommandParser` interface.
3. This results in the creation of `XYZSuggestionCommand` object which implements `SuggestionCommand` interface.
`XYZSuggestionCommand` is then executed by the `LogicManager`.
4. The command execution can affect the `Model` (e.g. `open` command will set the response text in the model as
"Open a note" and store a list of `SuggestionItem` in the model).
5. The UI will then be able to retrieve the response text and list of `SuggestionItem` from the model to be displayed
to the user.

Given below is the Sequence Diagram for interactions within the `Logic` and `Suggestion` component for the `execute("open /")` API call.

.Interactions Inside the Logic and Suggestion Component for the `open /` Command
image::SuggestionSequenceDiagram.png[]

NOTE: The lifeline for `OpenSuggestionCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.


[[Design-CorrectionEngine]]
==== CorrectionEngine component

.Class Diagram of the CorrectionEngine Component
image::CorrectionEngineClassDiagram.png[]

The `CorrectionEngine` component revolves around two _API_ s, namely:



Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

* The link:{repoURL}/src/main/java/com/notably/logic/correction/CorrectionEngine.java[`CorrectionEngine`] interface, implemented by `StringCorrectionEngine` and `AbsolutePathCorrectionEngine`. Concrete implementations of `CorrectionEngine` are employed to correct an uncorrected user input.
* The link:{repoURL}/src/main/java/com/notably/logic/correction/distance/EditDistanceCalculator.java[`EditDistanceCalculator`] interface, implemented by `LevenshteinDistanceCalculator`. Concrete implementations of `EditDistanceCalculator` are employed to calculate the https://en.wikipedia.org/wiki/Edit_distance[edit distance] between two strings.


Given below is the Sequence Diagram for interactions within the `StringCorrectionEngine` (one concrete implementation of `CorrectionEngine`) component for the `correct("uncorrected")` API call.

.Interactions inside the StringCorrectionEngine component for the `correct("uncorrected")` call
image::StringCorrectionEngineSequenceDiagram.png[]

//tag::design-model[]
[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/com/notably/model/Model.java[`Model.java`]

The `Model`,

* stores and manipulates the `BlockTree` data that represents a tree of Blocks, through BlockModel
* stores and manipulates a list of suggestions based on the user's input, through SuggestionModel
* stores the current state of the `View`, through ViewStateModel
** stores the command input given by the user, through CommandInputModel
** stores the state of the `help` modal being open, through HelpFlagModel
* stores `UserPref` data that represents the user's preferences, through UserPrefModel
//end::design-model[]

//tag::design-storage[]
[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/com/notably/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in JSON format and read it back.
* can save the Block data in JSON format and read it back.
//end::design-storage[]

[[Design-Commons]]
=== Commons component

Classes used by multiple components are in the `com.notably.commons` package.

[[Design-Compiler]]
=== Compiler component

.Class Diagram of the Compiler Component
image::CompilerClassDiagram.png[]

The `Compiler` component's primary usage is to compile Markdown to HTML.
Our `Compiler` component's design is based off https://github.github.com/gfm[GitHub's GFM Specification].

Mainly, the `Compiler` component consists of the following classes:

* link:{repoURL}/src/main/java/com/notably/commons/compiler/Compiler.java[`Compiler`], which deals with the end-to-end job of compiling unprocessed Markdown to HTML.
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/Parser.java[`Parser`], which deals with creating an https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Sytax Tree] representation of an unprocessed Markdown.
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`], which is an abstract class representing a node in a Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree]. All concrete implementations of nodes in a Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree] inherit from this class.

The concrete implementations of the link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`] class consist of:

* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/DocumentBlock.java[`DocumentBlock`], which represents the root of the Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree].
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/HeaderBlock.java[`HeaderBlock`], which represents a Markdown https://github.github.com/gfm/#atx-headings[ATX heading] component.
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/ListBlock.java[`ListBlock`], which represents a Markdown unordered list.
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/ListItemBlock.java[`ListItemBlock`], which represents a Markdown list item.
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/ParagraphBlock.java[`ParagraphBlock`], which represents a Markdown paragraph.
* link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/TextBlock.java[`TextBlock`], which represents plain text in Markdown.

Two of link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]'s _abstract_ methods are particularly important:

* https://github.com/AY1920S2-CS2103T-W17-2/main/blob/10267c0494bf7e58bd9c8e7f198bb7f9209631e2/src/main/java/com/notably/commons/compiler/parser/block/Block.java#L42[`Block#next`]: This method should be implemented by each of link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]'s implementation in such a way that accepts a single `String` line and evolve the current Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree] further. That way, each of link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]'s implementation only needs to care about processing the portion of the `String` line that is relevant to them, before delegating the rest to its children link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]s.
* https://github.com/AY1920S2-CS2103T-W17-2/main/blob/10267c0494bf7e58bd9c8e7f198bb7f9209631e2/src/main/java/com/notably/commons/compiler/parser/block/Block.java#L49[`Block#toHtml`]: This method should be implemented by each of link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]'s implementation in such a way that it returns the HTML representation of the current link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]. That way, each of link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]'s implementation only needs to care about generating its own HTML; the rest can be delegated to its children link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/Block.java[`Block`]s.

In short, our link:{repoURL}/src/main/java/com/notably/commons/compiler/Compiler.java[`Compiler`] class will first call the https://github.com/AY1920S2-CS2103T-W17-2/main/blob/10267c0494bf7e58bd9c8e7f198bb7f9209631e2/src/main/java/com/notably/commons/compiler/parser/Parser.java#L15-L23[`Parser#parse`] method to generate a Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree].
After that, the link:{repoURL}/src/main/java/com/notably/commons/compiler/Compiler.java[`Compiler`] class will transform the returned Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree] into HTML by calling the root link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/block/DocumentBlock.java[`DocumentBlock`]'s `toHtml` method (which will in turn invoke each of its children's `toHtml` method).

Given below is the _Sequence Diagram_ for interactions within the `Compiler` component for the `compile(markdown)` API call.

.Interactions inside the Compiler component for the `compile(markdown)` call
image::CompilerSequenceDiagram.png[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Design-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Design-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Implementation

This section describes the details on how features are implemented.

[[Implementation-CorrectionEngine]]
===  Correction Engine

==== Rationale

`CorrectionEngine` is needed to enable auto-correction of user inputs, to deliver as good typing experience as possible.

==== Current implementation

`CorrectionEngine` revolves around two _API_ s, namely:

* The link:{repoURL}/src/main/java/com/notably/logic/correction/CorrectionEngine.java[`CorrectionEngine`] interface, implemented by `StringCorrectionEngine` and `AbsolutePathCorrectionEngine`. Concrete implementations of `CorrectionEngine` are employed to correct an uncorrected user input.
* The link:{repoURL}/src/main/java/com/notably/logic/correction/distance/EditDistanceCalculator.java[`EditDistanceCalculator`] interface, implemented by `LevenshteinDistanceCalculator`. Concrete implementations of `EditDistanceCalculator` are employed to calculate the https://en.wikipedia.org/wiki/Edit_distance[edit distance] between two strings.

Two concrete implementations of the `CorrectionEngine` interface are, namely:

* The `StringCorrectionEngine` class, which deals with the correction of plain strings.
* The `AbsolutePathCorrectionEngine` class, which deals with the correction of absolute paths. The absolute paths here refer to the address of the notes (or blocks, as we call it) that exist in the App.

==== Design considerations

1. `CorrectionEngine` is built as a standalone module that can be used by both <<Implementation-SuggestionEngine,*`SuggestionEngine`*>> and <<Implementation-Parser,*`Parser`*>>. This decision is made so that code duplication in relation to auto-correction is minimal.
2. Both `CorrectionEngine` and `EditDistanceCalculator` are implemented as interfaces, in an attempt to make the design of the `CorrectionEngine` component resilient to change. This design enables us to leverage on the https://en.wikipedia.org/wiki/Strategy_pattern[strategy pattern] to make our `CorrectionEngine` component more future-proof.

[[Implementation-SuggestionEngine]]
=== Suggestion Engine

==== Rationale

`SuggestionEngine` allows the users to traverse their notes conveniently, without having
to remember the hierarchical structure of their notes. `SuggestionEngine` gives users the meaning of the command they input and a list of notes suggestions that they want to
open/ delete/ search/ edit.

==== Current implementation

1. `Logic` uses the `SuggestionEngineImpl` class, which implements `SuggestionEngine` interface, to parse the user command.
2. According to the command the user inputs, `SuggestionEngineImpl` will create a `XYZSuggestionCommandParser` object
which implements `SuggestionCommandParser` interface.
3. This results in the creation of `XYZSuggestionCommand` object which implements `SuggestionCommand` interface.
`XYZSuggestionCommand` is then executed by the `LogicManager`.
4. The command execution can affect the `Model` (e.g. `open` command will set the response text in the model as
"Open a note" and store a list of `SuggestionItem` in the model).
5. The UI will then be able to retrieve the response text and list of `SuggestionItem` from the model to be displayed
to the user.

==== Design considerations

1. `SuggestionEngine` is segregated from `Parser` in order to differentiate the logic when the user has finished typing
and pressed `enter` (which will be handled by `Parser`) in contrast to when the user presses `tab` to take in the
suggestion item.
2. In order to keep the App's data flow unidirectional, `SuggestionEngine` will update the response text (which tells
the user the meaning of his command) and the list of `SuggestionItem` into the `Model`. Thus, by not showing the
response text and suggestions immediately to the UI, `SuggestionEngine` will not interfere with the `View` functionality.
3. `SuggestionEngine`, `SuggestionCommandParser`, `SuggestionCommand`, `SuggestionItem`, and `SuggestionModel` are
implemented as interfaces, in an attempt to make the design of the `SuggestionEngine` component resilient to change.

// tag::paths[]
[[Implementation-Path]]
=== Paths
Given below is the implementation detail of the Path feature and some alternative design considerations.

==== Current Implementation
The `Path` interface represents the directory of a `Block` in our data structure. A path can exist in 2 forms namely :

. AbsolutePath
. RelativePath

An AbsolutePath is a path that takes its reference from the root `/` block. +
While a RelativePath takes it reference from the current directory that is opened.

Currently the user is given the freedom to provide any of the 2 forms when using the `open`, `delete` command. +
Given the following DataStructure below. +

.DataStructure example to illustrate Path
image::PathExample1.png[]

Using `AbsolutePath` `open /CS2101` and using `RelativePath` `open ../CS2101` would yield the same result Design Consideration.

==== Design Consideration

*Aspect: Implementation of `Path`* :

*   Alternative 1(Current choice): Have 2 separate class implementing `Path`, which is  `AbsolutePath` and `RelativePath`.
**  Pros: More readable and OOP, each class can have their individual validity REGEX.
*   Alternative 2: Implement a single class `PathImpl` and have a boolean flag `isAbsolute` to tell if
its a Relative or Absolute path.

*Aspect: Logical equivalence of `RelativePath`* :

*   Alternative 1(Current choice): Relative path `CS2103/../note1` would be equivalent to `note1`. This was deem to be
**  Pros: More readable and OOP, each class can have their individual validity REGEX.
*   Alternative 2: Relative path `CS2103/../note1` would not be logically equivalent to `note1`.

// end::paths[]
//tag::datastructure[]
[[Implementation-DataStructure]]
=== Tree Data Structure
Notably aims to provide end user a neat and well-organized workspace to store their notes. This is done by creating a tree structure; allowing users to create folder-like paths to organize their notes and group them into categories to their own liking.

==== Rationale
While this can be done with a linear data structure (a simple list), a linear list of notes would require more work to establish the relationship between groups of notes. A tree data structure supports this better, giving a clearer distinction while also establishing a form of hierarchy (as seen in the design example below).

On top of that, observability must be ensured so that the UI can update with any changes that happen on the tree (and its nodes) and also the data within each node.

==== Current Implementation
A custom tree data structure that supports observability has been implemented. The tree (referred to as `BlockTree`) is made up of tree nodes (referred to as `BlockTreeItem`). The tree is observable such that if any change occurs on any of the tree's nodes, the change event will bubble upwards to the root node. Hence, the root node serves as the entry point for the `BlockTree`.

Each BlockTreeItem contains 3 primary components:

* a reference to its parent
* an ObservableList of its children
* User's note data (referred to as `Block` data) consisting of:
** `Title` of the note
** `Body` content of the note (optional)

When manipulating the `BlockTree`, the execution of any operation is always split in this order:

1. Navigate to the specfied path
2. Open the block at the specified path
3. Execute the operation on the block that is currently open

==== Design Considerations
===== Aspect: `BlockTreeItem` vs Folders to represent path structure
Current choice: `BlockTreeItem`
Pros: No need for an additional class. Having a separate `folder` object would also require a separate UI View since folders should not contain any block data.
Cons: Somewhat unconventional design. User might be unfamiliar with the intention on first use, without proper explanation

===== Aspect: Root should also be a `BlockTreeItem`
Pros: Seamless transition to JSON storage
Cons: Need to add constraint  to ensure that the root `BlockTreeItem` does not contain any `Body` and is also unmodifiable

.Tree Data Structure Design Example
image::TreeDataStructureDesign.png[]
//end::datastructure[]

[[Implementation-Compiler]]
===  Compiler

==== Rationale

`Compiler` is needed to enable compilation of Markdown to HTML. By having an Markdown to HTML compiler, we can allow user to format their notes in Markdown, which enhances their note-editing experience tremendously.

==== Current implementation

The implementation of `Compiler` is highly inspired by https://github.github.com/gfm/#appendix-a-parsing-strategy[the parsing strategy] explained in https://github.github.com/gfm[GitHub's GFM Specification]. Please read more from the specification for a more comprehensive explanation.

==== Design considerations

Generally speaking, compilers usually consist of several main components, namely a tokenizer, a parser, and a generator. However, this is not the case in our design of the link:{repoURL}/src/main/java/com/notably/commons/compiler/Compiler.java[`Compiler`] component:

. Leveraging on the fact that Markdown's syntax is not overly complicated, we decided not to fully adhere to the usual compiler design. Instead, we merged the tokenizer and parser section into our link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/Parser.java[`Parser`] class. This link:{repoURL}/src/main/java/com/notably/commons/compiler/parser/Parser.java[`Parser`] class thus deals converting raw Markdown string into a Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree].
. In addition, we opted to not build a standalone generator component. Instead, we make it such that each node in our Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree] supports a `toHtml` method, which returns the HTML representation of the tree starting from itself as a node. This way, we can leverage on OOP's polymorphism to generate the HTML string out of our Markdown https://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree] a lot easier.

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

// tag::Scope&User[]
[appendix]
== Product Scope

*Target user profile*:

* Students that has a need to take notes and organize them into categories
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: Take and manage notes faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |student |traverse my notes in a file system-like manner | so that I can skim through my sea of notes and drafts without any problem.

|`* * *` |student |search my notes by their content | I won’t have to remember the exact titles I had given my notes.

|`* * *` |impatient student |alias a path to a folder | do not have to memorise and type out the entire file structure when accessing a nested note

|`* *` |student |can view the relevant search results| so that I don’t need to worry about remembering the exact location and title of notes

|`* *` |student |reliably type search commands(not error-prone) | focus on searching my notes rather than ensuring my commands are exact

|`*` |student |export my notes into PDF documents | share/print my notes effortlessly.

|=======================================================================

// end::Scope&User[]
_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `AddressBook` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Traverse notes

*MSS*

1.  User types in the title of note/subnotes to traverse to
2.  Notably opens the target note
+
Use case ends.

[discrete]
=== Use case: Search notes

*MSS*

1.  User types in the approximate title or content of note intended to be opened
2.  Notably lists out the relevant search results
3.  User chooses one of the suggested notes
4.  Notably opens the chosen note
+
Use case ends.

[discrete]
=== Use case: Note alias

*MSS*

1.  User types in a command to open a note by an alias name
2.  Notably opens the aliased note
+
Use case ends.

_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 notes without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
